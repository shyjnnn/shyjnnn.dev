---
title: 서버 컴포넌트 이모저모
date: 2023년 11월 14일
slug: what-is-server-component
tags: Next.js, React.js
summary: 서버 컴포넌트.. 너 뉘기야
category: 🙏잡학사전
---

> [[10분 테코톡] 에디의 서버 컴포넌트](https://www.youtube.com/watch?v=vjBQks_tjOA&t=304s)를 중심으로 정리한 글입니다.

컴포넌트가 서버에서 렌더링되면 서버 컴포넌트이다.

<aside>
💡 들어가기에 앞서 우선 기존의 클라이언트 컴포넌트란 무엇일까?
</aside>

## 클라이언트 컴포넌트

- 클라이언트 측 인터랙션을 추가할 수 있다.
  - 즉, 클라이언트에서 hydrated 된다.
- `[use client](https://react.dev/reference/react/use-client)`
  - 서버와 클라이언트 컴포넌트 모듈 그래프 사이의 경계를 선언하는 컨벤션이다.
  - Server-only 코드와 클라이언트 코드 사이에 위치한다.
  - 파일 최상단에 위치해 cut-off 지점을 정의한다.
  - 해당 컴포넌트, 하위 컴포넌트, import한 모듈 모두 클라이언트 번들의 일부로 간주된다.
    - entry point에서 한번만 정의하면 된다.

## 서버컴포넌트의 특징

1. 리렌더링이 되지 않는다.
   - 서버에서 렌더링이 되고 난 뒤에 클라이언트에 넘어오기 때문에 리렌더링이 되지 않는다.
2. 서버에서 렌더링이 되기 때문에 백엔드 리소스에 접근이 자유롭게 가능하다.
   - 파일시스템이나 데이터 베이스 등
   - 프론트엔드에서 기존에 접근하지 못했던 여러 시도가 가능하다.
3. 자바스크립트 번들에 포함되지 않는다.
   - 제로 번들 사이즈를 구현할 수 있다.
4. 자동 코드 스플릿팅을 지원한다.
   - 서버 컴포넌트에서 임포트되는 컴포넌트를 자동으로 spliting point로 간주하기 때문에 기존의 lazy loading, dynamic import 등을 명시할 필요가 없다.
5. User Interactivity는 제공이 불가하다.
   - state, effect 관리 등의 제공이 불가하다.

## 서버사이드 렌더링(SSR)과 서버 컴포넌트(RSC)의 차이

> 서버에서 렌더링된다는 공통점이 존재하나, 둘은 전혀 다른 개념이다.

### 서버사이드 렌더링

- **초기 html을 생성해** 좀 더 큰 범위, 웹페이지 단위로 렌더링 해주는 단위
- 모든 컴포넌트의 코드를 자바스크립트 번들에 포함하게 된다.
- next.js의 SSR에서 백엔드 리소스에 접근을 하려면, 최상위 페이지에서 `getServerProps` 같은 함수를 사용하거나, 세부적인 컴포넌트 단위에서 백엔드 리소스에 접근하기 어렵ㄴ다.
- 상태를 저장하고 refetch를 할 경우 html을 새로 받아오기 때문에, 상태의 저장이 불가능하다.

### 서버 컴포넌트

- 컴포넌트 단위로 컴포넌트를 자바스크립트 번들에 포함되지 않게 서버에 실행시켜주는 방식이다.
- 서버 컴포넌트로 지정한 해당 컴포넌트의 코드는 자바스크립트 번들에 포함되지 않는다.
- 페이지 레벨에 상관없이 모든 서버 컴포넌트에서 백엔드 리소스에 접근이 가능하다.
- refetch 후 RSG payload라는 방식으로 받아오기 때문에 상태의 보존이 가능하다.

<aside>
💡 RSC가 SSR의 대체자는 아니다!

</aside>

서버 사이드 렌더링으로 초기 렌더링 속도를 빠르게 만들어주고, 서버 컴포넌트를 통해 제로 번들링을 구현하면 더욱 빠른 페이지 제공이 가능하다. 따라서 대체 관계 보다는 보완 관계라고 볼 수 있다.

## RSC의 사용법

일반적인 React만으로는 서버 컴포넌트를 사용하기 힘들다. 따라서 Next.js 13 version의 app router를 사용하는 것이 좋다. Next.js의 모든 컴포넌트는 기본적으로 서버 컴포넌트이며, `use client`를 사용해 클라이언트 컴포넌트로 만들 수 있다.

### 서버/클라이언트 컴포넌트의 기준

어떤 기준으로 서버/클라이언트 컴포넌트를 나누어야할까?

모든 컴포넌트를 서버 컴포넌트로 만들 수 있다면 가장 Best라고 한다. 그러나 User Interactivity를 제공하지 않기 때문에 쉽지 않다.

#### 기준

| 언제 사용할까?                                             | 서버 컴포넌트 | 클라이언트 컴포넌트 |
| ---------------------------------------------------------- | ------------- | ------------------- |
| 데이터 패칭                                                | O             | X                   |
| 백엔드에 직접 접근                                         | O             | X                   |
| 서버에 민감한 정보 유지                                    | O             | X                   |
| 서버에 대규모 종속성 유지 / 클라이언트 자바스크립트 줄이기 | O             | X                   |
| 상호작용 및 이벤트 리스너 추가                             | X             | O                   |
| State나 생명주기 Effect 사용                               | X             | O                   |
| browser-only API 사용                                      | X             | O                   |
| State, effect, brower-only API 기반의 커스텀 hook 사용     | X             | O                   |
| React Class component 사용                                 | X             | O                   |

## Boundaries (경계)

<img width="492" alt="Untitled" src="https://github.com/shyjnnn/shyjnnn.dev/assets/81355590/7067e009-fac2-4ce7-9f87-1e18517d713d">

#### 문제점

부모 컴포넌트가 클라이언트 컴포넌트이고, 자식 컴포넌트는 서버 컴포넌트일 때, 부모 컴포넌트에서 리렌더링이 발생할 때, 자식 컴포넌트는 서버 컴포넌트이기 때문에 리렌더링이 발생하지 않는다.

> 클라이언트 컴포넌트가 임포트하는 컴포넌트는 반드시 클라이언트 컴포넌트여야한다. 따라서 클라이언트 컴포넌트를 Leaves로 이동시켜 Client Boundary가 영향을 최소화 하는 것이 좋다.

### Client Boundary

부모 컴포넌트에서 해당 컴포넌트가 클라이언트 컴포넌트일 경우, 자식 컴포넌트는 모두 클라이언트 컴포넌트화된다.
![Untitled 1](https://github.com/shyjnnn/shyjnnn.dev/assets/81355590/b69e711a-0853-4e12-b458-3cb358a6431b)

이는 서버 컴포넌트를 사용해야하는 입장에선 제약조건일 수 있다. 이 문제는 **컴포넌트의 소유자 변경**을 통해 해결 할 수 있다.

### 컴포넌트의 소유자 변경

<img width="477" alt="Untitled 2" src="https://github.com/shyjnnn/shyjnnn.dev/assets/81355590/3ca94fd7-ff5d-4789-a236-7625782accf6">

#### 문제점

라이트/다크모드를 위한 상태를 사용해야하기 때문에 최상위 컴포넌트인 `App` 컴포넌트를 클라이언트 컴포넌트로 만들게 될 경우, `Header`, `Main` 등 모든 하위 컴포넌트가 클라이언트 컴포넌트가 된다.

#### 해결방법

1. state를 사용하는 로직만 `ColorProvider`컴포넌트로 분리한다.
2. 기존의 `App` 컴포넌트에서 `ColorProvider`를 import 해 와 `Header`, `Main` 상위 컴포넌트로 묶어준다.
   <img width="279" alt="Untitled 3" src="https://github.com/shyjnnn/shyjnnn.dev/assets/81355590/3892bc67-bee9-4be9-9ee0-1f1f5669be01">

   이 경우, 자식 컴포넌트인 `Header`, `Main`는 클라이언트 컴포넌트화가 되지 않고 서버컴포넌트로 활용이 가능하다.

<aside>
💡 컴포넌트 트리 구조 상 파일을 분리하긴 했지만, `ColorProvider`는 여전히 클라이언트 컴포넌트이며, `Header`, `Main`의 부모 컴포넌트인데, 왜 Client Boundary 조건이 적용되지 않을까?
</aside>

Client Boundary에서는 부모, 자식 관계가 중요한 것이 아니라 import하는 컴포넌트에 집중을 해야 한다.

`Header`, `Main` 컴포넌트의 렌더링을 `App` 컴포넌트 해당 파일에서 관리를 하고 있기 때문에 `Header`, `Main` 컴포넌트의 렌더링도 `App` 컴포넌트가 결정한다. `App` 컴포넌트는 클라이언트 컴포넌트가 아니기 때문에 헤더와 메인의 컴포넌트도 클라이언트 컴포넌트와 규칙에 자유롭게 된다.

# 출처

- [[10분 테코톡] 에디의 서버 컴포넌트](https://www.youtube.com/watch?v=vjBQks_tjOA&t=304s)
- [[10 Years of React] 서버 컴포넌트](https://velog.io/@jiseung/10-Years-of-React#%EC%84%9C%EB%B2%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-%EB%93%B1%EC%9E%A5-%EB%B0%B0%EA%B2%BD)
