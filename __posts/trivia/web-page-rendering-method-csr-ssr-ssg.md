---
title: 웹 페이지 렌더링 방식 CSR, SSR, SSG
date: 2023년 5월 30일
slug: 웹-페이지-렌더링-방식-CSR-SSR-SSG
tags: CS, Network
category: 🙏잡학사전
---

## Clinet Side Rendering (CSR)

> 클라이언트 측 렌더링(CSR)은 JavaScript를 사용하여 브라우저에서 직접 페이지를 렌더링하는 것을 의미합니다. 모든 로직, 데이터 가져오기, 템플릿, 라우팅은 서버가 아닌 클라이언트에서 처리됩니다.

CSR에서 서버는 빈 HTML 페이지와 모든 로직을 처리하는 JavaScript 번들을 반환합니다. 따라서 JavaScript 번들의 크기의 영향을 많이 받기 때문에, **적극적인 코드 분할** (`code splitting`)을 고려해야하며, **필요한 것만 필요할 때 제공**해야 합니다.

![Untitled](https://github.com/shyjnnn/shyjnnn.dev/assets/81355590/19033344-9b17-482b-9d22-ead89611d5cf)

출처 : [medium](https://tapajyoti-bose.medium.com/frontend-rendering-ssg-vs-isg-vs-ssr-vs-csr-when-to-use-which-1bf9f39ff07c)

### 동작 방식

1. 사용자가 웹 페이지에 접속하면(request) 서버는 빈 HTML 파일을 응답(response)으로 전송합니다.
   - 이 HTML 파일(`index.html`)에는 일반적으로 **`<script>`**, **`<meta>`**, **`<link>`** 태그가 포함되어 있습니다. 이 HTML 파일은 동적 콘텐츠가 없는 진입점 역할을 합니다.
2. 브라우저는 HTML 파일에서 참조하는 JavaScript 번들을 다운로드합니다.
   - 이 번들은 데이터를 가져오고 최종 콘텐츠를 렌더링하는 코드를 포함하고 있습니다.
3. JavaScript 번들이 로드되면, 해당 번들은 AJAX나 fetch를 사용하여 API 요청을 보내 데이터를 가져옵니다. 데이터를 가져온 후 번들은 최종 콘텐츠를 렌더링합니다.
4. 사용자가 다른 페이지로 이동할 경우, 서버로부터 추가 HTML 파일을 요청하지 않고 이미 받은 JavaScript를 사용하여 페이지를 렌더링합니다.

![Untitled 1](https://github.com/shyjnnn/shyjnnn.dev/assets/81355590/a9238a57-81e6-40d1-b64a-f2897829bb31)

### 장점

- 동적 콘텐츠가 포함된 페이지를 생성할 수 있습니다.
  - 서버를 호출할 때마다 전체 UI를 다시 로드할 필요가 없습니다.
- 서버 비용이 증가하지 않습니다.
  - CSR은 서버 측에서 페이지 렌더링을 처리하지 않기 때문에 추가적인 서버 자원이 필요하지 않습니다.
- 초기 로드 후 다른 페이지의 로딩 속도가 매우 빠릅니다.
  - CSR은 이미 필요한 지원 스크립트를 미리 로드하기 때문에 후속 페이지 로딩 시간이 감소합니다.
  - 즉, `TTFB`(Time To First Byte)가 빠른 편입니다.
    - 초기 요청 후 서버에서 첫 번째 바이트를 수신하는 시간이 짧다는 것을 의미합니다.
  - 스크립트가 캐시되어 있다면 인터넷 없이도 CSR 웹 애플리케이션을 실행할 수 있습니다.

### 단점

- SEO(검색 엔진 최적화)에 적합하지 않습니다.
  - 검색 엔진 크롤러가 페이지를 처음 방문했을 때 빈 페이지이기 때문에 페이지를 이해할 수 없습니다. 일부 검색 엔진 크롤러(구글 크롤러 등)는 JavaScript를 실행할 수 있지만, 아직 많은 검색 엔진 크롤러가 JavaScript를 지원하지 않습니다.
- 초기 페이지 로드 시간이 서버 측 렌더링(SSR)에 비해 느릴 수 있습니다.
  - CSR은 초기 로딩 시간이 더 오래 걸리므로 사용자에게 페이지가 보여지기까지의 대기 시간이 더 길어질 수 있습니다.
  - 초기 요청 후에는 추가적인 데이터 및 컨텐츠를 가져와야 하기 때문에, 전체 페이지 로딩 시간(`TTI`: Total Time to Interactive)는 SSR에 비해 오래걸릴 수 있습니다.
- 페이지 메타데이터의 변경을 위한 추가적인 노력이 필요합니다
  - 한 페이지에서 다른 페이지로 변할 경우 이를 인지 시켜주기 위해 각 페이지에 대한 메타 데이터를 설정하고 클라이언트에서 렌더링하기 위해 추가 노력이 필요합니다.
- 사용자 경험(UX)가 좋지 않습니다
  - CSR은 초기 페이지 로딩 시간이 오래 걸리기 때문에 사용자는 빈 페이지를 보게 되므로 사용자 경험이 좋지 않을 수 있습니다.
- 클라이언트의 하드웨어 및 소프트웨어에 너무 많이 의존합니다
  - CSR은 클라이언트 측에서 페이지를 렌더링하기 때문에 사용자의 하드웨어 및 소프트웨어에 의존합니다.
  - 사용자의 기기가 하위 호환성이 없거나 최적의 성능을 제공하지 않는 경우, 페이지 렌더링이 최적의 시간에 이루어지지 않을 수 있습니다.
    - 이로 인해 페이지 로드 시간이 증가하고, 페이지 이탈률이 높아질 수 있습니다. (페이지 이탈률과 페이지 로드 시간 정비례)
    - 이탈률이 높을수록 검색엔진 순위도 낮아 질 수 있습니다.

### \***\*When to use CSR?\*\***

CSR은 SEO에 크게 의존하지 않는 모든 사이트에서 이상적입니다.

Tauri 또는 Electron과 같은 도구를 사용 풍부한 사이트 interactions과 웹, 크로스 플랫폼 애플리케이션을 만드는 데 사용할 수 있습니다.

## Server Side Rendering (SSR)

> 애플리케이션이 웹 페이지를 브라우저에서 렌더링하는 대신 **서버에서 생성**하는 기능입니다. **서버에서 완전히 렌더링 된 페이지**를 클라이언트로 보내고, **클라이언트의 자바스크립트 번들이 SPA 프레임워크의 작동을 대신**하는 방식입니다.

SSR에서는 페이지가 서버에서 렌더링되어 클라이언트로 전송되기 때문에 동적 데이터를 사용하면서도 뛰어난 SEO 최적화를 유지할 수 있습니다..

![Untitled 2](https://github.com/shyjnnn/shyjnnn.dev/assets/81355590/31e75496-1324-4150-8981-4d4429318c7e)

출처 : [medium](https://tapajyoti-bose.medium.com/frontend-rendering-ssg-vs-isg-vs-ssr-vs-csr-when-to-use-which-1bf9f39ff07c)

### **동작 방식**

1. 사용자가 웹 페이지를 방문하면 서버에 요청(request)을 보냅니다.
2. 서버는 해당 요청을 받고, 페이지에 필요한 데이터를 패치하고 서버 측 스크립트를 실행하여 HTML 컨텐츠를 준비합니다.
3. 준비된 HTML은 클라이언트 브라우저로 전송되어 응답(response)됩니다.
4. 브라우저는 HTML을 다운로드하고 해당 페이지를 렌더링하여 최종 사용자에게 보여줍니다.
5. 브라우저는 자바스크립트 파일을 다운로드하고 실행하여 페이지를 Interactive로 만들어 사용자와 상호작용할 수 있게 합니다.
6. 사용자가 다른 페이지로 이동하면, 위의 과정을 반복하여 새로운 페이지를 렌더링합니다.

![Untitled 3](https://github.com/shyjnnn/shyjnnn.dev/assets/81355590/98823f58-e715-4ab2-8fbd-810942d032dc)

### 장점

- 동적 콘텐츠가 포함된 페이지를 만드는 데 사용할 수 있습니다.
- SSG만큼 빠르지는 않지만 페이지가 로드되는 즉시 표시되는 콘텐츠가 표시되므로 **체감 성능이 빠릅**니다.
  - 서버에서 페이지 로직 및 렌더링을 실행하므로 `TTI`(Time to Interactive)가 빠르게 수행될 수 있습니다.
- SEO(검색 엔진 최적화)에 친화적입니다.
  - 이미 완성된 페이지를 검색 엔진 크롤러가 요청에 대한 응답으로 받기 때문에 검색 엔진이 콘텐츠를 쉽게 찾을 수 있습니다.
- 클라이언트 하드웨어 및 소프트웨어 성능에 영향을 덜 받습니다.
  - 서버는 일반적으로 더 높은 컴퓨팅 성능과 네트워킹 속도를 가지고 있으므로 서버에서 완성된 페이지만 클라이언트에게 전달하면 됩니다.
  - 따라서 클라이언트의 부담이 `CSR`에 비해 덜합니다.

### 단점

- 페이지 이동시마다 서버에서 페이지를 생성하는데 시간이 걸리기 때문에 `TTFB`(Time to First Byte)가 느릴 수 있습니다.
- 서버의 호스팅이 필요합니다.
  - HTML파일과 안에 내용을 생성해야 하기 때문에 서버 호스팅이 필요합다.
- `CDN` 캐싱에 제약이 있습니다.
  - 서버는 항상 각 요청이 올때마다 HTML파일을 생성하기 때문에 `CDN` 수준에서의 컨텐츠 캐시가 되지 않습니다.
- SSR은 모든 요청이 서버에서 처리되므로 서버의 높은 연산 능력이 필요합니다.
- SSR 사이트는 공격할 수 있는 지점이 더 넓기 때문에 보안을 유지하기가 더 어렵습니다.

### \***\*When to use SSR?\*\***

SSR은 서버 비용을 크게 증가시킬 가능성이 있는 만큼, 매우 자주 변경되고 SEO에 크게 의존하는 매우 동적인 콘텐츠가 있는 사이트에만 드물게 사용해야 합니다.

- ex) organic search을 통해 사용자를 모으는 주식 시세 웹사이트

<aside>
💡 ***극단적인 CSR과 SSR은 서로 상반!***

`CSR`의 장점은 `SSR`의 단점, `CSR`의 단점은 `SSR`의 장점입니다.

</aside>

## Static Site Generator(SSG)

> raw 데이터와 템플릿 세트를 기반으로 완전한 정적 HTML 웹사이트를 생성하는 프로세스입니다. 기본적으로개별 HTML 페이지를 코딩하는 작업을 자동화하고 해당 페이지를 사용자에게 미리 제공할 수 있도록 준비합니다.

즉, SSG는 빌드 타입에 **웹사이트의 모든 페이지를 미리 렌더링**하여 클라이언트의 요청에 따라 제공합니다. `Next.js`에서 권장하는 렌더링 방식입니다.

![Untitled 4](https://github.com/shyjnnn/shyjnnn.dev/assets/81355590/cdff1bf7-48f7-40dd-89f6-8b8d6875869f)

출처: [medium](https://tapajyoti-bose.medium.com/frontend-rendering-ssg-vs-isg-vs-ssr-vs-csr-when-to-use-which-1bf9f39ff07c)

### 동작 방식

1. 사용자가 웹 페이지를 방문하면, 사용자의 요청(request)은 엣지 서버에 도달합니다.
2. 엣지 서버는 먼저 해당 요청에 대한 캐시를 확인합니다.
   - 만약 요청한 컨텐츠가 이미 엣지 서버에 캐싱되어 있다면, 엣지 서버는 저장된 캐시를 사용자에게 반환합니다. 이 경우, 원격 서버로부터 데이터를 가져오지 않고도 빠르게 응답할 수 있습니다.
   - 요청한 컨텐츠가 엣지 서버에 캐싱되어 있지 않거나 캐시의 유효기간이 만료된 경우, 엣지 서버는 원격 서버로부터 해당 컨텐츠를 가져옵니다.
     - 가져온 컨텐츠는 엣지 서버에 캐싱되어 다음에 동일한 요청이 발생할 때 사용됩니다.
3. 엣지 서버는 가져온 컨텐츠를 최종 사용자에게 반환하고, 브라우저는 해당 컨텐츠를 다운로드하여 웹 페이지를 표시합니다.
4. 엣지 서버는 일정 기간 동안 캐싱된 컨텐츠를 유지하며, 이를 통해 웹 페이지 로딩 속도를 향상시킬 수 있습니다.

<aside>
💡 **엣지 캐싱(edge caching)이란?**

최종 사용자에게 더 빠른 응답 속도를 제공하고, 원격 서버의 부하를 줄이는 등 성능 개선을 위해 사용됩니다. 또한, 지리적으로 분산된 엣지 서버를 사용하면 웹 페이지의 로딩 시간을 지연시킬 수 있는 네트워크 지연을 줄일 수 있습니다. CDN(Content Delivery Network)은 엣지 캐싱을 구현하는 대표적인 방법 중 하나입니다.

</aside>

![Untitled 5](https://github.com/shyjnnn/shyjnnn.dev/assets/81355590/f8d0bd29-da04-434f-9a7d-6062d24441c9)

### **장점**

- 데이터베이스나 서버 측 프로세스가 거의 필요하지 않은 완전히 정적인 HTML 기반 사이트를 생성할 수 있습니다.
- 빌드 시점에 미리 만들어져 사용자에게 제공될 준비가 되어 있기 때문에 가장 빠른 형태의 웹 페이지입니다.
  - 빠른 `FP` (First Paint), `FCP` (First Contentful Paint), `TTI` (Time to Interactive)를 제공합니다.
  - 매 요청마다 생성하는 것이 아니므로, `SSR`과 달리 일관성있게 빠른 `TTFB` (Time to First Byte)를 달성할 수 있습니다.
- 웹사이트가 미리 만들어져 있기 때문에 콘텐츠가 훨씬 더 안전합니다.
- SEO (검색 엔진 최적화)에 친화적입니다.

### **단점**

- 콘텐츠 편집 및 게시가 어렵습니다.
  - 편집자는 단순한 웹 앱 인터페이스가 아닌 Git 리포지토리에 대한 액세스 권한이 필요할 수 있습니다.
- 모든 URL에 대해 개별 HTML 파일을 생성해야 합니다.
  - URL을 미리 예측할 수 없거나 URL을 예측할 수 없으면 적용이 어렵습니다.
- 콘텐츠를 업데이트하려면 사이트를 재빌드하고 테스트한 후 최종적으로 배포해야 합니다.
- 대규모 웹사이트를 유지 관리할 경우, 관리가 매우 번거롭고 빌드 시간도 많이 소요됩니다.

### \***\*When to use SSG?\*\***

SSG에는 많은 이점이 있지만 제품 쇼케이스 웹사이트와 같이 콘텐츠가 거의 변경되지 않는 웹사이트를 운영하는 경우에만 사용해야 합니다.

블로그가 있는 경우 수정할 때마다 사이트를 다시 배포해도 괜찮다면 SSG를 사용할 수 있습니다.

모든 형태의 동적 콘텐츠가 있는 사이트의 경우 SSG는 엄격히 금지됩니다.

## 마무리

이 외에도 추가적으로 ISR(Incremental Static Regeneratio), Univeral Rendering이 있습니다. 렌더링 방법은 프로젝트의 요구 사항과 UX 계획에 따라 전적으로 달라집니다. 전체 웹사이트에 한 가지 방법만 고수할 필요도 없으며, 페이지마다 다른 방법을 사용할 수 있습니다.

## 출처

- [https://ajdkfl6445.gitbook.io/study/web/csr-vs-ssr-vs-ssg#client-side-rendering-csr](https://ajdkfl6445.gitbook.io/study/web/csr-vs-ssr-vs-ssg#client-side-rendering-csr)
- [https://tapajyoti-bose.medium.com/frontend-rendering-ssg-vs-isg-vs-ssr-vs-csr-when-to-use-which-1bf9f39ff07c](https://tapajyoti-bose.medium.com/frontend-rendering-ssg-vs-isg-vs-ssr-vs-csr-when-to-use-which-1bf9f39ff07c)
