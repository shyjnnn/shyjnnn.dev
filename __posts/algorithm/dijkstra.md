---
title: λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦
date: 2023-06-13
slug: λ‹¤μµμ¤νΈλΌ-Dijkstra-μ•κ³ λ¦¬μ¦
tags: Algorithm, Dijkstra
category: π§®Algorithm
---

# **λ‹¤μµμ¤νΈλΌ(dijkstra)**

## κ°λ…

> ν• μ¶λ°μ (μ •μ  - λ…Έλ“)μ—μ„ λ¨λ“  λ‹¤λ¥Έμ§€μ κΉμ§€μ μµλ‹¨κ±°λ¦¬λ¥Ό κµ¬ν•λ” μ•κ³ λ¦¬μ¦ μ¤‘ ν•λ‚
> 
> 
> <aside>
> π’΅ μµμ† λΉ„μ© κµ¬ν•λ” μ•κ³ λ¦¬μ¦μ μΆ…λ¥
> 
> - λ‹¤μµμ¤νΈλΌ(dijkstra) μ•κ³ λ¦¬μ¦
> - λ²¨λ§-ν¬λ“ μ•κ³ λ¦¬μ¦
> - ν”„λ΅μ΄λ“ μ›μƒ¬ μ•κ³ λ¦¬μ¦
> </aside>
> 

λ„μ°© λ…Έλ“ λΏλ§ μ•„λ‹λΌ **λ¨λ“  λ‹¤λ¥Έ λ…Έλ“κΉμ§€ μµλ‹¨ κ²½λ΅λ΅ λ°©λ¬Έ**ν•λ©° κ° λ…Έλ“κΉμ§€μ μµλ‹¨ κ²½λ΅λ¥Ό λ¨λ“ μ°Ύκ² λλ‹¤. μ¦‰, λ§¤λ² μµλ‹¨ κ²½λ΅μ λ…Έλ“λ¥Ό μ„ νƒν•΄ νƒμƒ‰μ„ λ°λ³µν•λ” κ²ƒ!

## λ™μ‘ λ‹¨κ³„

β‘  μ¶λ° λ…Έλ“μ™€ λ„μ°© λ…Έλ“λ¥Ό μ„¤μ •ν•λ‹¤.

β‘΅ 'μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”'μ„ μ΄κΈ°ν™”ν•λ‹¤.

β‘Ά ν„μ¬ μ„μΉν• λ…Έλ“μ μΈμ ‘ λ…Έλ“ μ¤‘ λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“λ¥Ό κµ¬λ³„ν•κ³ , **λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό μ„ νƒ**ν•λ‹¤. κ·Έ λ…Έλ“λ¥Ό **λ°©λ¬Έ μ²λ¦¬**ν•λ‹¤.

β‘£ ν•΄λ‹Ή λ…Έλ“λ¥Ό κ±°μ³ λ‹¤λ¥Έ λ…Έλ“λ΅ λ„μ–΄κ°€λ” **κ°„μ„  λΉ„μ©(κ°€μ¤‘μΉ)μ„ κ³„μ‚°**ν•΄ **'μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”'μ„ μ—…λ°μ΄νΈ**ν•λ‹¤.

β‘¤ β‘Ά~β‘£μ κ³Όμ •μ„ λ°λ³µν•λ‹¤.

## κµ¬ν„ λ°©λ²•

λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“λ¥Ό λ‹¤λ£¨λ” λ°©μ‹μ— λ”°λΌ 2κ°€μ§€μ λ°©λ²•μ΄ μλ‹¤.

### 1. μμ°¨ νƒμƒ‰

λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘ **κ±°λ¦¬κ°’μ΄ κ°€μ¥ μ‘μ€ λ…Έλ“**λ¥Ό μ„ νƒν•΄ λ‹¤μ νƒμƒ‰ λ…Έλ“λ΅ μ‚Όλ”λ‹¤. μ΄ λ…Έλ“λ¥Ό μ°Ύλ” λ°©μ‹μ΄ μμ°¨ νƒμƒ‰μ„ μ‚¬μ©ν•λ” κ²ƒμ΄λ‹¤.

- μ‹κ°„ λ³µμ΅λ„ : `O(N^2)`
    - κ±°λ¦¬ ν…μ΄λΈ”μ μ•μ—μ„λ¶€ν„° μ°Ύμ•„λ‚΄μ•Όν•λ―€λ΅ λ…Έλ“μ κ°μ λ§νΌ μμ°¨ νƒμƒ‰μ„ μν–‰ν•λ‹¤.
- μ½”λ“
    
    ```python
    import sys
    input = sys.stdin.readline
    INF = int(1e9)
    
    # λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“μ΄λ©΄μ„ μ‹μ‘λ…Έλ“μ™€ μµλ‹¨κ±°λ¦¬μΈ λ…Έλ“ λ°ν™
    def get_smallest_node():
        min_value = INF
        index = 0
        for i in range(1, n+1):
            if not visited[i] and distance[i] < min_value:
                min_value = distance[i]
                index = i
        return index
    
    # λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦
    def dijkstra(start):
        # μ‹μ‘λ…Έλ“ -> μ‹μ‘λ…Έλ“ κ±°λ¦¬ κ³„μ‚° λ° λ°©λ¬Έμ²λ¦¬
        distance[start] = 0
        visited[start] = True
        # μ‹μ‘λ…Έλ“μ μΈμ ‘ν• λ…Έλ“λ“¤μ— λ€ν•΄ μµλ‹¨κ±°λ¦¬ κ³„μ‚°
        for i in graph[start]:
            distance[i[0]] = i[1]
    
        # μ‹μ‘λ…Έλ“ μ μ™Έν• n-1κ°μ λ‹¤λ¥Έ λ…Έλ“λ“¤ μ²λ¦¬
        for _ in range(n-1):
            now = get_smallest_node()  # λ°©λ¬ΈX λ©΄μ„ μ‹μ‘λ…Έλ“μ™€ μµλ‹¨κ±°λ¦¬μΈ λ…Έλ“ λ°ν™
            visited[now] = True        # ν•΄λ‹Ή λ…Έλ“ λ°©λ¬Έμ²λ¦¬
            # ν•΄λ‹Ή λ…Έλ“μ μΈμ ‘ν• λ…Έλ“λ“¤ κ°„μ κ±°λ¦¬ κ³„μ‚°
            for next in graph[now]:
    						# μ‹μ‘->now κ±°λ¦¬ + now->nowμ μΈμ ‘λ…Έλ“ κ±°λ¦¬
                cost = distance[now] + next[1]
    						# cost < μ‹μ‘->nowμ μΈμ ‘λ…Έλ“ λ‹¤μ΄λ ‰νΈ κ±°λ¦¬
                if cost < distance[next[0]]:
                    distance[next[0]] = cost
    ```
    

### 2. μ°μ„ μμ„ ν

- μ‹κ°„ λ³µμ΅λ„ : `O(logN)`

μμ°¨ νƒμƒ‰μ„ μ‚¬μ©ν•  κ²½μ° λ…Έλ“ κ°μμ— λ”°λΌ νƒμƒ‰ μ‹κ°„μ΄ λ§¤μ° μ¤λ κ±Έλ¦΄ μ μλ‹¤. μ΄λ¥Ό κ°μ„ ν• κ²ƒμ΄ μ°μ„ μμ„ νλ¥Ό μ‚¬μ©ν•λ” λ°©λ²•μ΄λ‹¤.

κ±°λ¦¬ κ°’μ„ λ‹΄μ„ μ°μ„ μμ„ νλ” ν™μΌλ΅ κµ¬ν„ν•λ‹¤. 

- λ§μ•½ μµμ† ν™μΌλ΅ κµ¬ν„ν•λ‹¤λ©΄ λ§¤λ² λ£¨νΈ λ…Έλ“κ°€ μµμ† κ±°λ¦¬λ¥Ό κ°€μ§€λ” λ…Έλ“κ°€ λ  κ²ƒμ΄λ‹¤.
- νμ΄μ¬μ κ²½μ°Β `PriorityQueue`λ‚Β `heapq`Β λΌμ΄λΈλ¬λ¦¬λ΅ μ°μ„ μμ„ ν, μµμ† ν™μ΄ μ§€μ›λλ‹¤.

μ°μ„ μμ„ νμ—μ„ μ‚¬μ©ν•  **μ°μ„ μμ„**μ κΈ°μ¤€μ€ **μ‹μ‘ λ…Έλ“λ΅ λ¶€ν„° κ°€μ¥ κ°€κΉμ΄ λ…Έλ“**κ°€ λλ‹¤. λ”°λΌμ„ νμ μ •λ ¬μ€ μµλ‹¨ κ±°λ¦¬μΈ λ…Έλ“λ¥Ό κΈ°μ¤€μΌλ΅ μµλ‹¨ κ±°λ¦¬λ¥Ό κ°€μ§€λ” λ…Έλ“λ¥Ό μ•μ— λ°°μΉν•λ‹¤.

μ°μ„ μμ„ νλ¥Ό μ‚¬μ©ν•λ©΄ **λ°©λ¬Έ μ—¬λ¶€λ¥Ό κΈ°λ΅ν•  λ°°μ—΄μ΄ μ—†μ–΄λ„ λλ‹¤**. μ°μ„  μμ„ νκ°€ μ•μ•„μ„ **μµλ‹¨ κ±°λ¦¬μ λ…Έλ“λ¥Ό μ•μΌλ΅ μ •λ ¬**ν•κΈ° λ•λ¬Έμ—, **κΈ°μ΅΄ μµλ‹¨ κ±°λ¦¬λ³΄λ‹¤ ν¬λ‹¤λ©΄ λ¬΄μ‹ν•λ©΄ λλ‹¤**!

- λ§μ•½ κΈ°μ΅΄ μµλ‹¨ κ±°λ¦¬λ³΄λ‹¤ λ” μ‘μ€ κ°’μ„ κ°€μ§€λ” λ…Έλ“κ°€ μλ‹¤λ©΄, κ·Έ λ…Έλ“μ™€ κ±°λ¦¬λ¥Ό μ°μ„  μμ„ νμ— λ„£λ”λ‹¤.
- μ°μ„  μμ„ νμ— μ‚½μ… λλ” ν•νƒλ” `<κ±°λ¦¬, λ…Έλ“>` κΌ΄μ΄λ‹¤.

- μ½”λ“
    
    ```python
    import sys
    import heapq
    input = sys.stdin.readline
    
    n, m = map(int, input().split())
    start = int(input())
    INF = int(1e9)
    distance = [INF] * (n+1)
    graph = [[] for _ in range(n+1)]
    
    for _ in range(m):
        a, b, c = map(int, input().split())
        graph[a].append((b, c))
    
    def dijkstra(start):
        q = []
        heapq.heappush(q, (0, start))  # μ‹μ‘λ…Έλ“ μ •λ³΄ μ°μ„ μμ„ νμ— μ‚½μ…
        distance[start] = 0            # μ‹μ‘λ…Έλ“->μ‹μ‘λ…Έλ“ κ±°λ¦¬ κΈ°λ΅
        while q:
            dist, node = heapq.heappop(q)
            # νμ—μ„ λ½‘μ•„λ‚Έ κ±°λ¦¬κ°€ μ΄λ―Έ κ°±μ‹ λ κ±°λ¦¬λ³΄λ‹¤ ν΄ κ²½μ°(=λ°©λ¬Έν• μ…) λ¬΄μ‹
            if distance[node] < dist:
                continue
            # νμ—μ„ λ½‘μ•„λ‚Έ λ…Έλ“μ™€ μ—°κ²°λ μΈμ ‘λ…Έλ“λ“¤ νƒμƒ‰
            for next in graph[node]:
                cost = distance[node] + next[1]   # μ‹μ‘-> nodeκ±°λ¦¬ + node-> nodeμμΈμ ‘λ…Έλ“ κ±°λ¦¬
                if cost < distance[next[0]]:      # cost < μ‹μ‘-> nodeμμΈμ ‘λ…Έλ“ κ±°λ¦¬
                    distance[next[0]] = cost
                    heapq.heappush(q, (cost, next[0]))
    
    dijkstra(start)
    
    for i in range(1, len(distance)):
        if distance[i] == INF:
            print('λ„λ‹¬ν•  μ μ—†μ')
        else:
            print(distance[i])
    ```